import numpy as np
from scipy.spatial.transform import Rotation as R

class ThrustToAttitudeController:
    def __init__(self, FLT_EPSILON):
        self.FLT_EPSILON = FLT_EPSILON

    def thrust_to_attitude(self, thr_sp, yaw_sp, debug_step_signal=0.0):
        # Convert thrust setpoint to body_z axis
        body_z = -thr_sp

        # Zero vector, no direction, set safe level value
        if np.sqrt(np.linalg.norm(body_z)) < self.FLT_EPSILON:
            body_z[2] = 1.0
        
        # Normalize body_z
        body_z = body_z / np.linalg.norm(body_z)

        # Vector of desired yaw direction in XY plane, rotated by PI/2
        y_C = np.array([-np.sin(yaw_sp), np.cos(yaw_sp), 0.0])

        # Desired body_x axis, orthogonal to body_z
        body_x = np.cross(y_C, body_z)

        # Keep nose to front while inverted upside down
        if body_z[2] < 0.0:
            body_x = -body_x

        # Handle the case where the desired thrust is in the XY plane
        if abs(body_z[2]) < 0.000001:
            body_x = np.zeros(3)
            body_x[2] = 1.0

        # Normalize body_x
        body_x = body_x / np.linalg.norm(body_x)

        # Desired body_y axis
        body_y = np.cross(body_z, body_x)

        # Fill rotation matrix R_sp
        R_sp = np.column_stack((body_x, body_y, body_z))

        # Convert rotation matrix to quaternion
        quat = R.from_matrix(R_sp)
        q_sp = quat.as_quat()  # x, y, z, w format

        # Calculate Euler angles for logging (must not be used for control)
        eul_sp = quat.as_euler('ZYX')  # Yaw (psi), Pitch (theta), Roll (phi)
        att_sp = np.array([eul_sp[2], eul_sp[1], eul_sp[0]])  # Roll, Pitch, Yaw

        # Debug section (if needed)
        # Uncomment this section if you want to use the debug signals
        # if debug_step_signal > 0.5:
        #     eul_sp = np.array([0, 10*np.pi/180, 15*np.pi/180])
        # else:
        #     eul_sp = np.array([0, 0*np.pi/180, 0*np.pi/180])
        # att_sp = np.array([eul_sp[2], eul_sp[1], eul_sp[0]])  # Roll, Pitch, Yaw
        # R_sp = R.from_euler('ZYX', eul_sp).as_matrix()
        # q_sp = R.from_matrix(R_sp).as_quat()

        # The thrust on the body axis
        thrust_body = -np.linalg.norm(thr_sp)

        # Designed thrust generated by motors, which is non-negative
        net_thrust = -thrust_body

        return q_sp, att_sp, net_thrust


# Initialize the controller with a small FLT_EPSILON
FLT_EPSILON = 1e-6
controller = ThrustToAttitudeController(FLT_EPSILON)

# Example thrust setpoint and yaw setpoint
thr_sp = np.array([0.0, 0.0, -1.0])  # Thrust pointing straight up
yaw_sp = 0.0  # No yaw rotation

# Call the thrust_to_attitude function
q_sp, att_sp, net_thrust = controller.thrust_to_attitude(thr_sp, yaw_sp)

# Print the results
print("Quaternion Setpoint:", q_sp)
print("Attitude Setpoint (Euler Angles):", att_sp)
print("Net Thrust:", net_thrust)